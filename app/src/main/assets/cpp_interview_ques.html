<html>
<body>
  
<h2 id="best-c-interview-questions">Best C++ Interview Questions</h2>
<p><span style="font-weight: 400;">If you’re preparing for a job role with emphasis on C++, then here are 20 most important C++ interview questions to self-assess your C++ interview preparation:</span></p>
<h4 id="question-briefly-explain-the-concept-of-inheritance-in-c"><strong>Question</strong><span style="font-weight: 400;">: </span><strong>Briefly explain the concept of Inheritance in C++.</strong></h4>
<p><strong>Answer</strong><span style="font-weight: 400;">: C++ allows classes to inherit some of the commonly used state and behavior from other classes. This process is known as inheritance.</span></p>
<h4 id="question-define-c"><strong>Question: Define C++?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">C++ is a computer programming language that is a superset of C wherein additional features are made in the C language.&nbsp;</span></p><div style="margin-top: 15px; margin-bottom: 15px; margin-left: -6px" class="blog-ad-block">


<h4 id="question-can-we-call-c-as-oops-and-why"><strong>Question: Can we call C++ as OOPS? and Why?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">Yes, C++ can be called OOPS. The full form of OOPS is an Object-Oriented Programming System which means a paradigm that provides an application of various concepts including data binding, polymorphism, inheritance, and various others.</span></p>
<h4 id="question-define-class-in-c"><strong>Question: Define Class in C++?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">Class is referred to as the designing of the user-defined data type. It reflects the different entities, attributes, and actions.</span></p>
<h4 id="question-define-object-in-c"><strong>Question: Define Object in C++?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">Object is an instance of the class. An object can have fields, methods, constructors and related. For example, a bike in real life is an object, but it has various features such as brakes, color, size, design, and others which are instances of its class.</span></p>
<h4 id="question-define-encapsulation-in-c"><strong>Question: Define Encapsulation in C++?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">Encapsulation is the process of binding together the data and functions in a class. It is applied to prevent direct access to the data for security reasons. The functions of class are applied for this purpose. For example, the net banking facility to the customers allows only the authorized person with the required login id and password to get access and that too only for his/her part of the information in the bank datasource.</span></p>
<h4 id="question-what-is-an-abstraction-in-c"><strong>Question: What is an abstraction in C++?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">An abstraction in C++ is the process of hiding the internal implementations and displaying only the required details. For example, when you send an important message through email, at that time only writing and clicking the send option is used. This outcome is just the success message that is displayed to confirm you that your email has been sent. However, the process followed in transferring the data through email is not displayed because it is of no use to you.</span></p>
<h4 id="question-what-is-the-function-of-the-keyword-volatile"><strong>Question: What is the function of the keyword “Volatile”?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">"Volatile" is a function that helps in declaring that the particular variable is volatile and thereby directs the compiler to change the variable externally- this way, the compiler optimization on the variable reference can be avoided.</span></p>
<h4 id="question-define-storage-class-in-c-name-some"><strong>Question: Define storage class in C++? Name some?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">Storage class in C++ specifically resemble life or even the scope of symbols, including the variables, functions, etc. Some of the storage class names in C++ include mutable, auto, static, extern, register, etc.</span></p>
<h4 id="question-can-we-have-a-recursive-inline-function-in-c"><strong>Question<span style="font-weight: 400;">:</span> Can we have a recursive inline function in C++?</strong></h4>
<p><strong>Answer<span style="font-weight: 400;">:</span> </strong><span style="font-weight: 400;">Even though it is possible to call an inline function from within itself in C++, the compiler may not generate the inline code. This is so because the compiler won’t be able to determine the depth of the recursion at the compile time.</span></p>
<p><span style="font-weight: 400;">Nonetheless, a compiler with a good optimizer is able to inline recursive calls until some depth fixed at compile-time, and insert non-recursive calls at compile time for the cases when the actual depth exceeds at run time.</span></p>
<h4 id="question-define-an-inline-function-in-c-write-its-syntax-is-it-possible-for-the-c-compiler-to-ignore-inlining"><strong>Question<span style="font-weight: 400;">: </span>Define an Inline Function in C++? Write its syntax. Is it possible for the C++ compiler to ignore inlining?</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: In order to reduce the function call overhead, C++ offers inline functions. As the name suggests, an inline function is one that is expanded in line when it is called.</span></p><div style="margin-top: 15px; margin-bottom: 15px; margin-left: -6px" class="blog-ad-block">
<div id="gpt-passback-stpd-3-1572966252313">
  <script>
     window.googletag = window.googletag || {cmd: []};
       googletag.cmd.push(function() {
         googletag
           .defineSlot('/147246189/hackr.io_728x250_blog_post_2_DFP', [[300, 250], [728, 90]], 'gpt-passback-stpd-3-1572966252313')
           .addService(googletag.pubads());
         googletag.enableServices();
         googletag.display('gpt-passback-stpd-3-1572966252313');
     });
  </script>
</div>
</div>
<p><span style="font-weight: 400;">As soon as the inline function is called, the whole code of the same gets either inserted or substituted at the particular point of the inline function call. The substitution is complete by the C++ compiler at compile time. Small inline functions might increase program efficiency.</span></p>
<p><span style="font-weight: 400;">The syntax of a typical inline function is:</span></p>
<pre class="hljs javascript"><span style="font-weight: 400;">Inline <span class="hljs-keyword">return</span>-type <span class="hljs-function"><span class="hljs-keyword">function</span>-<span class="hljs-title">name</span>(<span class="hljs-params">parameters</span>)</span></span><span class="hljs-function">
</span><span style="font-weight: 400;">{</span>
<span style="font-weight: 400;"><span class="hljs-comment">// Function code goes here</span></span>
<span style="font-weight: 400;">}</span>
</pre>
<p><span style="font-weight: 400;">As the inlining is a request, not a command, the compiler can ignore it.</span></p>
<h4 id="question-explain-this-pointer"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>Explain ‘this’ pointer?</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: The ‘this’ pointer is a constant pointer and it holds the memory address of the current object. It passes as a hidden argument to all the nonstatic member function calls. Also, it is available as a local variable within the body of all the nonstatic functions.</span></p>
<p><span style="font-weight: 400;">As static member functions can be called even without any object, i.e. with the class name, the ‘this’ pointer is not available for them.</span></p>
<h4 id="question-why-do-we-need-the-friend-class-and-function"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>Why do we need the Friend class and function?</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: Sometimes, there is a need for allowing a particular class to access private or protected members of a class. The solution is a friend class, which is capable of accessing the protected as well as the private members of the class in which it is declared as a friend.</span></p>
<p><span style="font-weight: 400;">Similarly to the friend class, a friend function is able to access private and protected class members. A friend function can either be a global function or a method of some class.</span></p>
<p><span style="font-weight: 400;">Some important points about friend class and friend function:</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Friendship is not inherited</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Friendship isn’t mutual i.e. if some class called Friend is a friend of some other class called NotAFriend then it doesn’t automatically become a friend of the Friend class</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">The total number of friend classes and friend functions should be limited in a program as the overabundance of the same might lead to a depreciation of the concept of encapsulation of separate classes, which is an inherent and desirable quality of object-oriented programming</span></li>
</ul>
<h4 id="question-explain-the-significance-of-vtable-and-vptr-in-c-and-how-the-compiler-deals-with-them"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>Explain the significance of vTable and vptr in C++ and how the compiler deals with them</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: vTable is a table containing function pointers. Every class has a vTable. vptr is a pointer to vTable. Each object has a vptr. In order to maintain and use vptr and vTable, the C++ compiler adds additional code at two places:</span></p>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">In every constructor</span><span style="font-weight: 400;"> – This code sets vptr:</span>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">Of the object being created</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">To point to vTable of the class</span></li>
</ol>
</li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Code with the polymorphic functional call</span><span style="font-weight: 400;"> – At every location where a polymorphic call is made, the compiler inserts code in order to first look for vptr using the base class pointer or reference. The vTable of a derived class can be accessed once the vptr is successfully fetched. Address of derived class function show() is accessed and called using the vTable.</span></li>
</ol>
<h4 id="question-how-is-function-overloading-different-from-operator-overloading"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>How is function overloading different from operator overloading?</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: Function overloading allows two or more functions with different type and number of parameters to have the same name. Operator overloading, on the other hand, allows for redefining the way an operator works for user-defined types.</span></p><div style="margin-top: 15px; margin-bottom: 15px; margin-left: -6px" class="blog-ad-block">

<h4 id="question-is-it-possible-for-a-c-program-to-be-compiled-without-the-main-function"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>Is it possible for a C++ program to be compiled without the main() function?</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: Yes, it is possible. However, as the main() function is essential for the execution of the program, the program will stop after compiling and will not execute.</span></p>
<h4 id="question-draw-a-comparison-between-c-and-java"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>Draw a comparison between C++ and Java</strong></h4>
<p><strong>Answer</strong><span style="font-weight: 400;">:</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">C++ has destructors, which are invoked automatically when an object is destroyed. Java has something called automatic garbage collection</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">C++ supports multiple inheritance, operator overloading, pointers, structures, templates, and unions. Java doesn’t have any of them</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Java has a Thread class that is inherited in order to create a new thread. C++ has no inbuilt support for threads</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">In C++, a goto statement offers a way to jump from a location to some labeled statement in the same function. There is no goto statement in Java</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">C++ run and compile using the compiler, which converts the source code into machine level language. Hence, it is platform-dependent. Java compiler, on the other hand, converts the source code into JVM bytecode, which is platform-independent.</span></li>
</ul>
<h4 id="question-take-a-look-at-the-following-c-program"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>Take a look at the following C++ program:</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>:</span></p>
<pre class="hljs cpp"><span style="font-weight: 400;"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span></span>
<span style="font-weight: 400;"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span>
<span style="font-weight: 400;"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span></span><span class="hljs-function">
</span><span style="font-weight: 400;">{</span>
<span style="font-weight: 400;"> <span class="hljs-keyword">int</span> numbers[<span class="hljs-number">5</span>], sum = <span class="hljs-number">0</span>;</span>
<span style="font-weight: 400;"> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter 5 numbers: "</span>;</span>
<span style="font-weight: 400;"> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) </span>
<span style="font-weight: 400;"> {</span>
<span style="font-weight: 400;"> <span class="hljs-built_in">cin</span> &gt;&gt; numbers[i];</span>
<span style="font-weight: 400;"> sum += numbers[i];</span>
<span style="font-weight: 400;"> }</span>
<span style="font-weight: 400;"> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Sum = "</span> &lt;&lt; sum &lt;&lt; <span class="hljs-built_in">endl</span>; </span>
<span style="font-weight: 400;"> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span>
<span style="font-weight: 400;">}</span>
</pre>
<h4 id="question-what-will-be-the-output"><strong>Question<span style="font-weight: 400;">: </span>What will be the output?</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: The program will ask the user to enter 5 numbers and will then present with their sum as the output. For instance,</span></p>
<p><span style="font-weight: 400;">Enter 5 numbers: 22</span><br><span style="font-weight: 400;">25</span><br><span style="font-weight: 400;">32</span><br><span style="font-weight: 400;">46</span><br><span style="font-weight: 400;">66</span></p>
<p><span style="font-weight: 400;">Sum = 191</span></p>
<h4 id="question-what-are-the-most-important-differences-between-c-and-c"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>What are the most important differences between C and C++?</strong></h4>
<p><strong>Answer</strong><span style="font-weight: 400;">:</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">C++ supports references while C doesn’t</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Features like friend functions, function overloading, inheritance, templates, and virtual functions are inherent to C++. These are not available in C programming language</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">In C, exception handling is taken care of in the traditional if-else style. On the other hand, C++ offers support for exception handling at the language level</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Mainly used input and output in C are scanf() and printf(), respectively. In C++, cin is the standard input stream while cout serves as the standard output stream</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">While C is a </span><a href="https://hackr.io/blog/procedural-programming"><span style="font-weight: 400;">procedural programming language</span></a><span style="font-weight: 400;">, C++ provides support for both procedural and object-oriented programming approaches</span></li>
</ul>
<h4 id="question-explain-virtual-functions-and-the-concept-of-runtime-polymorphism-in-c-with-a-code-example"><strong>Question<span style="font-weight: 400;">:</span></strong> <strong>Explain Virtual Functions and the concept of Runtime Polymorphism in C++ with a code example.</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: Any function when accompanying the </span><span style="font-weight: 400;">virtual</span><span style="font-weight: 400;"> keyword exhibits the behavior of a virtual function. Unlike normal functions that are called in accordance with the type of pointer or reference used, virtual functions are called as per the type of the object pointed or referred.</span></p>
<p><span style="font-weight: 400;">In simple terms, virtual functions resolve at runtime, not anytime sooner. Use of virtual functions could also be understood as writing a C++ program leveraging the concept of </span><a href="https://www.quora.com/What-exactly-is-the-runtime-polymorphism-in-C++" target="_blank" rel="noopener"><span style="font-weight: 400;">runtime polymorphism</span></a><span style="font-weight: 400;">. Things essential to writing a virtual function in C++ are:</span></p>
<ul>
<li><span style="font-weight: 400;">A base class</span></li>
<li><span style="font-weight: 400;">A derived class</span></li>
<li><span style="font-weight: 400;">A function with the same name in both the classes i.e. the base class and the derived class</span></li>
<li><span style="font-weight: 400;">A pointer or reference of base class type that points or refers, respectively to an object of the derived class</span></li>
</ul>
<p><span style="font-weight: 400;">An example demonstrating the use of virtual functions (or runtime polymorphism at play) is:</span></p>
<pre class="hljs cpp"><span style="font-weight: 400;"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span></span>
<span style="font-weight: 400;"> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span>
<span style="font-weight: 400;"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> {</span> </span>
<span style="font-weight: 400;"> <span class="hljs-keyword">public</span>: </span>
<span style="font-weight: 400;"> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">" In Base \n"</span>; } </span>
<span style="font-weight: 400;"> };</span>
<span style="font-weight: 400;"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span>:</span> <span class="hljs-keyword">public</span> Base { </span>
<span style="font-weight: 400;"> <span class="hljs-keyword">public</span>: </span>
<span style="font-weight: 400;"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>{ <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"In Derived \n"</span>; } </span>
<span style="font-weight: 400;"> }; </span>
 
<span style="font-weight: 400;"> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{ </span>
<span style="font-weight: 400;"> Base *bp = <span class="hljs-keyword">new</span> Derived; </span>
<span style="font-weight: 400;"> bp-&gt;show(); <span class="hljs-comment">// &lt;- Runtime Polymorphism in Action</span></span>
<span style="font-weight: 400;"> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span>
<span style="font-weight: 400;">}</span></pre>
<p><span style="font-weight: 400;">In the aforementioned program bp is a pointer of type Base. A call to bp-&gt;show() calls show() function of the Derived class. This is because bp points to an object of the Derived class.</span></p><div style="margin-bottom: 15px; margin-left: -6px" class="blog-ad-block">

<h4 id="question-what-differences-separate-structure-from-a-class-in-c"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>What differences separate structure from a class in C++?</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: There are two important distinctions between a class and a structure in C++. These are:</span></p>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">When deriving a structure from a class or some other structure, the default access specifier for the base class or structure is public. On the contrary, default access specifier is private when deriving a class.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">While the members of a structure are public by default, the members of a class are private by default</span></li>
</ol>
<h4 id="question-what-does-a-static-member-in-c-mean"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>What does a Static member in C++ mean? </strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: Denoted by the static keyword, a static member is allocated storage, in the static storage area, only once during the program lifetime. Some important facts pertaining to the static members are:</span></p>
<ul>
<li style="font-weight: 400;"><span style="font-weight: 400;">Any static member function can’t be virtual</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">Static member functions don’t have ‘this’ pointer</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">The const, const volatile, and volatile declaration aren’t available for static member functions</span></li>
</ul>
<h4 id="question-define-access-specifier-and-its-various-types-in-c"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>Define access specifier and its various types in C++</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: An access specifier offers the means by which it is possible to define how the class members, i.e. functions and variables, will be accessed outside the </span><a href="https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/cplr059.htm" target="_blank" rel="noopener"><span style="font-weight: 400;">scope of the class</span></a><span style="font-weight: 400;">. There are three types of access specifier in C++:</span></p>
<ul>
<li><strong><span style="font-weight: 400;">Private – Such class members can’t be accessed outside the class in which they are declared and are only accessible within the same class. Even child classes are disabled to access private members of its parent class</span></strong></li>
</ul>
<ul>
<li><strong><span style="font-weight: 400;">Protected – In addition to the class in which they are declared, the child classes can access the protected members of its parent class</span></strong></li>
</ul>
<ul>
<li><strong><span style="font-weight: 400;">Public – Class members declared as public can be accessed throughout the program (code)</span></strong></li>
</ul>
<h4 id="question-define-the-copy-constructor-used-in-c-along-with-its-general-function-prototype-also-explain-the-various-scenarios-in-which-it-is-called"><span style="font-weight: 400;"><strong>Question</strong>: </span><strong>Define the Copy Constructor used in C++ along with its general function prototype. Also, explain the various scenarios in which it is called.</strong></h4>
<p><span style="font-weight: 400;"><strong>Answer</strong>: A member function that initializes an object using another object of the same class is known as a copy constructor in C++. The Copy Constructor can also be made private. A call to the Copy Constructor can happen in any of the following 4 scenarios, when:</span></p>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">The compiler generates a temporary object</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">An object is constructed or based on some another object of the same class</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">An object of the class is returned by value</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">An object of the class is passed (i.e. to a function) by value as an argument</span></li>
</ol>
<p><span style="font-weight: 400;">The general function prototype for the Copy Constructor is:</span></p>
<p><span style="font-weight: 400;">ClassName (const ClassName &amp;old_obj);</span><br><span style="font-weight: 400;">Point(int x1, int y1) { x=x1; y=y1;}</span><br><span style="font-weight: 400;">Point(const Point &amp;p2) { x=p2.x; y=p2.y; }</span></p>
<h4 id="question-observe-the-following-code-snippet"><strong>Question<span style="font-weight: 400;">:</span> Observe the following code snippet:</strong></h4>
<p><span style="font-weight: 400;">int i = 5;</span><br><span style="font-weight: 400;">int j = i++;</span></p>
<p><strong>After execution, what will be the value of i and j? Explain your answer.</strong></p>
<p><strong>Answer<span style="font-weight: 400;">:</span> </strong><span style="font-weight: 400;">Post the execution of the code above, i and j will be 6 and 5, respectively. For understanding the output, it’s important to understand how the unary ‘++’ operator and the decrement ‘--’ operator works in C++.</span></p>
<p><span style="font-weight: 400;">When any of these operators precede a variable, the value of the variable is first modified and then this modified value is used. However, when any of the two operators follow a variable, the value is first used and then it is modified.</span></p>
<p><span style="font-weight: 400;">Therefore, in the code above j is set to the unmodified value of 5 and then i is incremented to store 6.</span></p><div style="margin-bottom: 15px; display: flex; justify-content: center" class="blog-ad-block">

</div>
<h4 id="question-take-a-look-at-the-following-two-code-examples-for-printing-a-vector"><strong>Question<span style="font-weight: 400;">:</span> Take a look at the following two code examples for printing a vector:</strong></h4>
<pre class="hljs cpp"><strong>Sample Code <span class="hljs-number">1</span>:</strong>

<span style="font-weight: 400;"><span class="hljs-built_in">vector</span> vec;</span>
<span style="font-weight: 400;"><span class="hljs-comment">/* ... .. ... */</span></span>
<span style="font-weight: 400;"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = vec.begin(); itr != vec.end(); itr++) {</span>
 <span style="font-weight: 400;">itr-&gt;print();</span>
<span style="font-weight: 400;">}</span>

<strong>Sample Code <span class="hljs-number">2</span>:</strong>

<span style="font-weight: 400;"><span class="hljs-built_in">vector</span> vec;</span>
<span style="font-weight: 400;"><span class="hljs-comment">/* ... .. ... */</span></span>
<span style="font-weight: 400;"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = vec.begin(); itr != vec.end(); ++itr) {</span>
 <span style="font-weight: 400;">itr-&gt;print();</span>
<span style="font-weight: 400;">}</span>
</pre>
<p><strong>Is there any advantage of using one over the other?</strong></p>
<p><strong>Answer<span style="font-weight: 400;">:</span> </strong><span style="font-weight: 400;">Though both codes will generate the same output, sample code 2 is a more performant option. This is due to the fact that the post-increment ‘itr++’ operator is more expensive than the pre-increment ‘++itr’ operator.</span></p>
<p><span style="font-weight: 400;">The post-increment operator generates a copy of the element before proceeding with incrementing the element and returning the copy. Moreover, most compilers will automatically optimize the sample code 1 by converting it implicitly into the sample code 2.</span></p>
<h4 id="question-suppose-you-have-the-gpa-grade-point-average-of-n-number-of-students-and-you-need-to-store-and-display-it-using-c-can-you-write-a-program-that-accomplishes-this"><strong>Question<span style="font-weight: 400;">: </span>Suppose you have the GPA (Grade Point Average) of n number of students and you need to store and display it using C++. Can you write a program that accomplishes this?</strong></h4>
<p><strong>Answer</strong><span style="font-weight: 400;">:</span></p>
<pre class="hljs cpp"><span style="font-weight: 400;"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span></span>
<span style="font-weight: 400;"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> </span></span>
<span style="font-weight: 400;"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;</span>
<span style="font-weight: 400;"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><span class="hljs-function">
</span><span style="font-weight: 400;">{</span>
<span style="font-weight: 400;"> <span class="hljs-keyword">int</span> num;</span>
<span style="font-weight: 400;"> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter the total number of students: "</span>;</span>
<span style="font-weight: 400;"> <span class="hljs-built_in">cin</span> &gt;&gt; num;</span>
<span style="font-weight: 400;"> <span class="hljs-keyword">float</span>* ptr;</span>
<span style="font-weight: 400;"> ptr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[num];</span>
<span style="font-weight: 400;"> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Enter the GPA of students."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span>
<span style="font-weight: 400;"> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i)</span>
<span style="font-weight: 400;"> {</span>
<span style="font-weight: 400;"> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Student"</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">": "</span>;</span>
<span style="font-weight: 400;"> <span class="hljs-built_in">cin</span> &gt;&gt; *(ptr + i);</span>
<span style="font-weight: 400;"> }</span>
<span style="font-weight: 400;"> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nDisplaying GPA of students."</span> &lt;&lt; <span class="hljs-built_in">endl</span>;</span>
<span style="font-weight: 400;"> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; ++i) {</span>
<span style="font-weight: 400;"> <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Student"</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">" :"</span> &lt;&lt; *(ptr + i) &lt;&lt; <span class="hljs-built_in">endl</span>;</span>
<span style="font-weight: 400;"> }</span>
<span style="font-weight: 400;"> <span class="hljs-keyword">delete</span> [] ptr;</span>
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</pre>
<p><span style="font-weight: 400;">}</span></p>
<h4 id="question-what-is-a-mutable-storage-class-specifier-how-can-they-be-used"><strong>Question: What is a mutable storage class specifier? How can they be used?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">A mutable storage class specifier is applied only on non-static and non-constant member variable of the class. It is used for altering the constant class object's member by declaring it. This can be done by using a storage class specifier.</span></p>
<h4 id="question-what-are-the-differences-between-a-shallow-copy-and-a-deep-copy"><strong>Question: What are the differences between a shallow copy and a deep copy?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">The differences between a shallow copy and a deep copy can be stated as under.</span></p>
<table>
<tbody>
<tr>
<td>Shallow Copy</td>
<td>Deep Copy</td>
</tr>
<tr>
<td>It allows memory dumping on a bit by bit basis from one object to another.</td>
<td>It allows the copy field, which is done by field from one object to another.</td>
</tr>
<tr>
<td>It is achieved by using copy instructor and overloading assignment operator.</td>
<td>It is used for shallow copy purposes.</td>
</tr>
</tbody>
</table>
<h4 id="question-define-an-abstract-class-in-c"><strong>Question: Define an Abstract class in C++?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">An abstract class in C++ is referred to as the base class, which has at least one pure virtual function. In such a function, a person cannot instantiate an abstract class. This way an Abstract class a pure virtual function is defined by using a pure specifier which is equal to zero during the declaration of the virtual member function in the class declaration. The code sample can be displayed as follows in example.</span></p>
<pre class="hljs ruby"><span style="font-weight: 400;">/<span class="hljs-regexp">/ An abstract class</span></span><br><span style="font-weight: 400;"><span class="hljs-regexp">class Test</span></span><br><span style="font-weight: 400;"><span class="hljs-regexp">{</span></span><span style="font-weight: 400;"><span class="hljs-regexp"> </span></span><br><span style="font-weight: 400;"><span class="hljs-regexp"> &nbsp;&nbsp;&nbsp;/</span><span class="hljs-regexp">/ Data members of class</span></span><br><span style="font-weight: 400;"><span class="hljs-regexp">public:</span></span><br><span style="font-weight: 400;"><span class="hljs-regexp"> &nbsp;&nbsp;&nbsp;/</span><span class="hljs-regexp">/ Pure Virtual Function</span></span><br><span style="font-weight: 400;"><span class="hljs-regexp"> &nbsp;&nbsp;&nbsp;virtual void show() = 0;</span></span><br><span style="font-weight: 400;"><span class="hljs-regexp"> &nbsp;&nbsp;/</span>* Other members *<span class="hljs-regexp">/</span></span><br><span style="font-weight: 400;"><span class="hljs-regexp">};</span></span></pre>
<h4 id="question-define-the-reference-variable"><strong>Question: Define the Reference variable?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">The reference variable in C++ is the name given to the existing variables. The variable name and reference variable point share the same memory location in C++, which helps in updating the original variable using the reference variable. The code can be displayed in the following example.</span></p>
<pre class="hljs shell"><span style="font-weight: 400;"><span class="hljs-meta">#</span><span class="bash">include&lt;iostream&gt;</span></span><br><span style="font-weight: 400;"><span class="bash">using namespace std;</span></span><br><span style="font-weight: 400;"><span class="bash">int <span class="hljs-function"><span class="hljs-title">main</span></span>()</span></span><br><span style="font-weight: 400;"><span class="bash">{</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;int x = 10;</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;// ref is a reference to x.</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;int&amp; ref = x;</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;// Value of x is now changed to 20</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;ref = 20;</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;cout &lt;&lt; <span class="hljs-string">"x = "</span> &lt;&lt; x &lt;&lt; endl ;</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;// Value of x is now changed to 30</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;x = 30;</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;cout &lt;&lt; <span class="hljs-string">"ref = "</span> &lt;&lt; ref &lt;&lt; endl ;</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;<span class="hljs-built_in">return</span> 0;</span></span><br><span style="font-weight: 400;"><span class="bash">} </span></span><strong><br></strong></pre>
<h4 id="question-can-we-have-a-string-primitive-data-type-in-c"><strong>Question; Can we have a String primitive data type in C++?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">No, we cannot have a String Primitive data type in C++. Instead, we can have a class from the Standard Template Library (STL).</span></p>
<h4 id="question-can-we-use-access-specifiers-to-achieve-data-hiding-in-c"><strong>Question: Can we use access specifiers to achieve data hiding in C++?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">Yes, we can use access specifiers to achieve data hiding in C++. These include Private and Protected.</span></p><div style="margin-bottom: 15px; display: flex; justify-content: center" class="blog-ad-block"></div>

<h4 id="question-what-is-a-destructor"><strong>Question: What is a destructor?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">A destructor is the member function of the class. It has the same name as the class name and also prefixed with a tilde symbol. It can be executed automatically whenever an object loses its scope.</span></p>
<h4 id="question-can-we-overload-a-destructor"><strong>Question: Can we overload a destructor?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">No, a destructor cannot be overloaded, and it has the only form without the parameters.</span></p>
<h4 id="question-what-is-the-default-constructor"><strong>Question: What is the default constructor?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">The compiler provides a constructor to every class in case the provider does not offer the same. This is when the programmer provides the constructor with no specific parameters than it is called a default constructor. The code for default constructor can be displayed in the following example.</span></p>
<pre class="hljs coffeescript"><span style="font-weight: 400;"><span class="hljs-regexp">//</span> Cpp program to illustrate the</span><br><span style="font-weight: 400;"><span class="hljs-regexp">//</span> concept <span class="hljs-keyword">of</span> Constructors</span><br><span style="font-weight: 400;"><span class="hljs-comment">#include &lt;iostream&gt;</span></span><br><span style="font-weight: 400;"><span class="hljs-comment">using namespace std;</span></span><br><span style="font-weight: 400;"><span class="hljs-comment">class construct {</span></span><br><span style="font-weight: 400;"><span class="hljs-comment">public:</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;int a, b;</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;// Default Constructor</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;construct()</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;{</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a = 10;</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b = 20;</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;}</span></span><br><span style="font-weight: 400;"><span class="hljs-comment">};</span></span><br><span style="font-weight: 400;"><span class="hljs-comment">int main()</span></span><br><span style="font-weight: 400;"><span class="hljs-comment">{</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;// Default constructor called automatically</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;// when the object is created</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;construct c;</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;cout &lt;&lt; "a: " &lt;&lt; c.a &lt;&lt; endl</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt; "b: " &lt;&lt; c.b;</span></span><br><span style="font-weight: 400;"><span class="hljs-comment"> &nbsp;&nbsp;&nbsp;return 1;</span></span><br><span style="font-weight: 400;"><span class="hljs-comment">}&nbsp;</span></span></pre>
<h4 id="question-can-we-provide-one-default-constructor-for-our-class"><strong>Question: Can we provide one default constructor for our class?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">No, we cannot provide one default constructor for our class. This is because when a variable in the class type is set to null then it means that it was never initialized and the outcomes will be zero.</span></p>
<h4 id="question-what-is-the-main-difference-between-the-keyword-struct-and-class"><strong>Question: What is the main difference between the keyword struct and class?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">The keyword struct is used for resembling public members by default, while the keyword class is used for resembling private members by default.</span></p>
<h4 id="question-define-block-scope-variable"><strong>Question: Define Block scope variable?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">A Block scope variable is the one that is specified as a block using the C++ that can be declared anywhere within the block.</span></p></div>
<h4 id="question-what-are-the-functions-of-the-scope-resolution-operator"><strong>Question: What are the functions of the scope resolution operator?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">The functions of the scope resolution operator include the following.</span></p>
<ol>
<li style="font-weight: 400;"><span style="font-weight: 400;">It helps in resolving the scope of various global variables.</span></li>
<li style="font-weight: 400;"><span style="font-weight: 400;">It helps in associating the function with the class when it is defined outside the class.</span></li>
</ol>
<p><span style="font-weight: 400;">The code of the scope resolution operator can be displayed as follows.</span></p>
<pre class="hljs shell"><span style="font-weight: 400;"><span class="hljs-meta">#</span><span class="bash">include &lt;iostream&gt;&nbsp; </span></span><br><span style="font-weight: 400;"><span class="bash">using namespace std;&nbsp; </span></span><br><span style="font-weight: 400;"><span class="bash">int my_var = 0;</span></span><br><span style="font-weight: 400;"><span class="bash">int main(void) {</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;&nbsp;int my_var = 0;</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;&nbsp;::my_var = 1;&nbsp; // <span class="hljs-built_in">set</span> global my_var to 1</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;&nbsp;my_var = 2;&nbsp; &nbsp; // <span class="hljs-built_in">set</span> <span class="hljs-built_in">local</span> my_var to 2</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;&nbsp;cout &lt;&lt; ::my_var &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; my_var;</span></span><br><span style="font-weight: 400;"><span class="bash"> &nbsp;&nbsp;<span class="hljs-built_in">return</span> 0;</span></span><br><span style="font-weight: 400;"><span class="bash">}</span></span></pre>
<h4 id="question-define-a-namespace"><strong>Question: Define a namespace?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">&nbsp;A namespace is used for resolving the name conflict of the identifier, which is accomplished by placing them under various namespaces. This way, it helps in the logical division of the different codes.</span></p>
<h4 id="question-define-a-class-template"><strong>Question: Define a class template?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">A class template is a name given to the generic class. The use of the keyword template is made for defining a class template.</span></p>
<h4 id="question-what-is-the-function-of-the-keyword-auto"><strong>Question: What is the function of the keyword "Auto"?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">The keyword “Auto” is used by default for various local variables for making function work automatically.&nbsp;</span></p>
<h4 id="question-define-a-token-in-c-give-examples"><strong>Question: Define a token in C++? Give examples?</strong></h4>
<p><strong>Answer: </strong><span style="font-weight: 400;">A token is a name given to the various functions in C++ programs. Examples of tokens include a keyword, symbol, string literal, identifier, constant, etc. The code of token in C++ other than C, can be displayed in the following example.</span></p>
<pre class="hljs cpp"><span style="font-weight: 400;"><span class="hljs-keyword">asm</span>&nbsp; &nbsp; &nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"><span class="hljs-keyword">bool</span>&nbsp; &nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"><span class="hljs-keyword">catch</span>&nbsp; &nbsp; &nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">class</span><br><span style="font-weight: 400;">const_cast &nbsp; <span class="hljs-keyword">delete</span> <span class="hljs-keyword">dynamic_cast</span> &nbsp; explicit</span><br><span style="font-weight: 400;">export &nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"><span class="hljs-literal">false</span> &nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"><span class="hljs-keyword">friend</span> &nbsp; &nbsp; &nbsp; &nbsp; inline</span><br><span style="font-weight: 400;">mutable&nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"><span class="hljs-keyword">namespace</span> &nbsp; <span class="hljs-keyword">new</span> </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">operator</span><br><span style="font-weight: 400;">private&nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"><span class="hljs-keyword">protected</span> &nbsp; <span class="hljs-keyword">public</span> </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">reinterpret_cast</span><br><span style="font-weight: 400;">static_cast&nbsp; <span class="hljs-keyword">template</span> <span class="hljs-keyword">this</span> &nbsp; &nbsp; &nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">throw</span><br><span style="font-weight: 400;">true &nbsp; &nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"><span class="hljs-keyword">try</span> &nbsp; &nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"><span class="hljs-keyword">typeid</span> &nbsp; &nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;">typename</span><br><span style="font-weight: 400;">using&nbsp; &nbsp; </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"><span class="hljs-keyword">virtual</span> </span><span style="font-weight: 400;"> </span><span style="font-weight: 400;"><span class="hljs-keyword">wchar_t</span></span></pre>
<h4 id="question-what-is-the-diamond-problem-that-occurs-with-multiple-inheritance-in-c-explain-using-an-example"><strong>Question<span style="font-weight: 400;">:</span> What is the ‘diamond problem’ that occurs with multiple inheritance in C++? Explain using an example.</strong></h4>
<p><strong>Answer<span style="font-weight: 400;">:</span> </strong><span style="font-weight: 400;">The diamond problem in C++ represents the inability of the programming language to support hybrid inheritance using multiple and hierarchical inheritance.</span></p>
<p><span style="font-weight: 400;">Suppose we have a university with some faculty members and some graduate students. A simple inheritance scheme in this scenario might have different types of people in different roles. However, all of them inherit from the same Person class.</span></p>
<p><span style="font-weight: 400;">The Person class defines an abstract getRole() method that would then be overridden by its subclasses in order to return the correct role type. Things up till this point is simple, however, if we wish to model the role of a TA or Teaching Assistant then things get weird.</span></p>
<p><span style="font-weight: 400;">A Teaching Assistant is both a student and a faculty member. This will yield the diamond problem, as illustrated in the figure below:</span></p>
<p><span style="font-weight: 400;">The problem generates an inheritance diagram resembling a diamond, hence the name, diamond problem.</span></p>
<p><span style="font-weight: 400;">Which getRole() implementation should the Teaching Assistant inherit? Graduate Student or the Faculty Member? A potential answer might be to have the Teaching Assistant class override the getRole() method and return a newly-defined role, say TA.</span></p>
<p><span style="font-weight: 400;">However, such an answer would also be far from complete as it will hide the fact that a Teaching Assistant is someone who is both a faculty member as well as a graduate student.</span></p>


</body>
</html>

